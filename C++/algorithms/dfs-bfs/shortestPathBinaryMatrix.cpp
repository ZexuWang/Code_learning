/*1091. 二进制矩阵中的最短路径
给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。

二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

路径途经的所有单元格都的值都是 0 。
路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
畅通路径的长度 是该路径途经的单元格总数。

 

示例 1：


输入：grid = [[0,1],[1,0]]
输出：2
示例 2：


输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
输出：4
示例 3：

输入：grid = [[1,0,0],[1,1,0],[1,1,0]]
输出：-1
 

提示：

n == grid.length
n == grid[i].length
1 <= n <= 100
grid[i][j] 为 0 或 1*/

/*解题思路
典型的BFS最短路径问题，用DFS也可以求解，但是容易超时。

在二维矩阵中搜索，什么时候用BFS，什么时候用DFS？
1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；
2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。

BFS解法中的visited为什么可以全局使用？
BFS是在尝试所有的可能路径，哪个最快到达终点，哪个就是最短。那么每一条路径走过的路不同，visited（也就是这条路径上走过的点）也应该不同，那么为什么visited可以全局使用呢？
因为我们要找的是最短路径，那么如果在此之前某个点已经在visited中，也就是说有其他路径在小于或等于当前步数的情况下，到达过这个点，证明到达这个点的最短路径已经被找到。那么显然这个点没必要再尝试了，因为即便去尝试了，最终的结果也不会是最短路径了，所以直接放弃这个点即可。

*/
class Solution {
public:
    int directions[8][8]={{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,0},{1,-1},{1,1}};//定义8个运动方向
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        //特殊条件判断
        int n = grid.size();
        if (grid[0][0] == 1) return -1;
        if (grid[n - 1][n - 1] == 1) return -1;
        if (n == 1) return 1;

        queue<pair<int, int>> q;
        q.push({0, 0});//将初始点压入队列
        grid[0][0] = 1;//将已经访问过的点改为1，以后不再访问
        int step = 1;
        while(!q.empty()) {
            int m = q.size();
            for (int r = 0; r < m; ++r) {
                auto cur = q.front();//此处不可以用 auto& ，否则会导致编译失败
                q.pop();
                int x = cur.first;
                int y = cur.second;
                for (int k = 0; k < 8; ++k) {
                    int new_x = x + directions[k][0];
                    int new_y = y + directions[k][1];
                    if (new_x >= 0 && new_y >= 0
                        && new_x < n && new_y < n) {
                        if (grid[new_x][new_y] == 0) {
                            q.push({new_x, new_y});//将符合条件的点再次压入队列中
                            grid[new_x][new_y] = 1;
                        }
                        if (new_x == n - 1 && new_y == n - 1) {
                            return step + 1;
                        }
                    }
                }
            }
            step += 1;//每一层算是一步，完成了一层给步数加一
        }
        return -1;
    }
};


